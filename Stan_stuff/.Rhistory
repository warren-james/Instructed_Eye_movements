)
fit6 <- stan(
file = "mafc_regression.stan",
data = cha_dat,
chains = 1,
warmup = 1000,
iter = 2000,
refresh = 100,
control = list(adapt_delta = 0.99)
)
post_fit6 <- rstan::extract(fit6)
b <- mean(post_fit6$b)
c <- mean(post_fit6$c)
# good(ish) plot, bad model
plot(x,y)
lines(x, logistic(pmax(0,b*x+c)))
m3
get_fx_for_sep <- function(d, post) {
# get fixed effects of model
# d is the scaled separtations we want to predict for
fx <- tibble(
condition = rep(c(
"Baseline",
"Instructed",
"Practice",
"Transfer"), each = length(post$c)),
delta = d,
samples = c(
0.5 + plogis(post$c + post$b * d),
0.5 + plogis(post$c + post$b_i + post$b * d),
0.5 + plogis(post$c + post$b_h + post$b * d),
0.5 + plogis(post$c + post$b_i + post$b_h + post$b * d )))
return(fx)
}
fx_min_sep  <- get_fx_for_sep(min(df$sep_scaled), post_samples)
fx_mean_sep <- get_fx_for_sep(mean(df$sep_scaled), post_samples)
fx_max_sep  <- get_fx_for_sep(max(df$sep_scaled), post_samples)
fx <- bind_rows(fx_min_sep, fx_mean_sep, fx_max_sep)
plt <- ggplot(fx, aes(x = samples, fill = condition))
plt <- plt + geom_density(alpha = 0.5)
plt <- plt + theme_bw()  + scale_fill_viridis_d()
plt <- plt + facet_wrap(~delta)
plt <- plt + scale_x_continuous(
name = "probablity of correctly responding to target", limits = c(0.2,1), expand = c(0,0))
plt
mafc.logit
summary(m3)
summary(m3)$c
mafc.logit
library(psych)
get_fx_for_sep <- function(d, post) {
# get fixed effects of model
# d is the scaled separtations we want to predict for
fx <- tibble(
condition = rep(c(
"Baseline",
"Instructed",
"Practice",
"Transfer"), each = length(post$c)),
delta = d,
samples = c(
0.5 + 0.5 * logistic(post$c + post$b * d),
0.5 + 0.5 * logistic(post$c + post$b_i + post$b * d),
0.5 + 0.5 * logistic(post$c + post$b_h + post$b * d),
0.5 + 0.5 * logistic(post$c + post$b_i + post$b_h + post$b * d )))
return(fx)
}
fx_min_sep  <- get_fx_for_sep(min(df$sep_scaled), post_samples)
fx_mean_sep <- get_fx_for_sep(mean(df$sep_scaled), post_samples)
fx_max_sep  <- get_fx_for_sep(max(df$sep_scaled), post_samples)
fx <- bind_rows(fx_min_sep, fx_mean_sep, fx_max_sep)
plt <- ggplot(fx, aes(x = samples, fill = condition))
plt <- plt + geom_density(alpha = 0.5)
plt <- plt + theme_bw()  + scale_fill_viridis_d()
plt <- plt + facet_wrap(~delta)
plt <- plt + scale_x_continuous(
name = "probablity of correctly responding to target", limits = c(0.2,1), expand = c(0,0))
plt
post$c + post$b * d
post_samples$c + post_samples$b * d
post_samples$c + post_samples$b * min(df$sep_scaled)
0.5 + 0.5 * (post_samples$c + post_samples$b * min(df$sep_scaled))
mafc.logit
View(post_samples)
head(0.5 + 0.5 * (logistic(post$c + post$b * min(df$sep_scaled))))
head(0.5 + 0.5 * (logistic(post_samples$c + post_samples$b * min(df$sep_scaled))))
head(0.5 + 0.5 * (logistic(post_samples$c + post_samples$b * 1)))
head(post_samples$b)
head(post_samples$c)
logistic(0.5)
0.5 + 0.5 * logistic(0.5)
get_fx_for_sep <- function(d, post) {
# get fixed effects of model
# d is the scaled separtations we want to predict for
fx <- tibble(
condition = rep(c(
"Baseline",
"Instructed",
"Practice",
"Transfer"), each = length(post$c)),
delta = d,
samples = c(
plogis(post$c + post$b * d),
plogis(post$c + post$b_i + post$b * d),
plogis(post$c + post$b_h + post$b * d),
plogis(post$c + post$b_i + post$b_h + post$b_hi + post$b * d )))
return(fx)
}
fx_min_sep  <- get_fx_for_sep(min(df$sep_scaled), post_samples)
fx_mean_sep <- get_fx_for_sep(mean(df$sep_scaled), post_samples)
fx_max_sep  <- get_fx_for_sep(max(df$sep_scaled), post_samples)
fx <- bind_rows(fx_min_sep, fx_mean_sep, fx_max_sep)
plt <- ggplot(fx, aes(x = samples, fill = condition))
plt <- plt + geom_density(alpha = 0.5)
plt <- plt + theme_bw()  + scale_fill_viridis_d()
plt <- plt + facet_wrap(~delta)
plt <- plt + scale_x_continuous(
name = "probablity of correctly responding to target", limits = c(0.2,1), expand = c(0,0))
plt
stan_df <- list(
N = nrow(df),
inst = df$given_instruction,
acc = df$correct,
half = df$second_half
)
# run model
m3_1 <- stan(
file = "exp3_m3_1.stan",
data = stan_df,
chains = 1,
warmup = 1000,
iter = 2000,
refresh = 100
)
save(m3_1, file = "scratch/models/m3_1")
post_samples <- as.tibble(rstan::extract(m3_1))
View(post_samples)
colnames(post_samples)
get_fx_for_sep <- function(d, post) {
# get fixed effects of model
# d is the scaled separtations we want to predict for
fx <- tibble(
condition = rep(c(
"Baseline",
"Instructed",
"Practice",
"Transfer"), each = length(post$c)),
delta = d,
samples = c(
plogis(post$c),
plogis(post$c + post$b_i),
plogis(post$c + post$b_h),
plogis(post$c + post$b_i + post$b_h + post$b_hi)))
return(fx)
}
fx_min_sep  <- get_fx_for_sep(min(df$sep_scaled), post_samples)
fx_mean_sep <- get_fx_for_sep(mean(df$sep_scaled), post_samples)
fx_max_sep  <- get_fx_for_sep(max(df$sep_scaled), post_samples)
fx <- bind_rows(fx_min_sep, fx_mean_sep, fx_max_sep)
plt <- ggplot(fx, aes(x = samples, fill = condition))
plt <- plt + geom_density(alpha = 0.5)
plt <- plt + theme_bw()  + scale_fill_viridis_d()
plt <- plt + facet_wrap(~delta)
plt <- plt + scale_x_continuous(
name = "probablity of correctly responding to target", limits = c(0.2,1), expand = c(0,0))
plt
post_samples
get_fx_for_sep <- function(post) {
# get fixed effects of model
# d is the scaled separtations we want to predict for
fx <- tibble(
condition = rep(c(
"Baseline",
"Instructed",
"Practice",
"Transfer"), each = length(post$c)),
samples = c(
plogis(post$c),
plogis(post$c + post$b_i),
plogis(post$c + post$b_h),
plogis(post$c + post$b_i + post$b_h + post$b_hi)))
return(fx)
}
fx <- get_fx_for_sep(post_samples)
plt <- ggplot(fx, aes(x = samples, fill = condition))
plt <- plt + geom_density(alpha = 0.5)
plt <- plt + theme_bw()  + scale_fill_viridis_d()
# plt <- plt + facet_wrap(~delta)
plt <- plt + scale_x_continuous(
name = "probablity of correctly responding to target", limits = c(0.2,1), expand = c(0,0))
plt
plt <- ggplot(fx, aes(x = samples, fill = condition))
plt <- plt + geom_density(alpha = 0.5)
plt <- plt + theme_bw()  + scale_fill_viridis_d()
# plt <- plt + facet_wrap(~delta)
plt <- plt + scale_x_continuous(
name = "probablity of correctly responding to target", limits = c(0.5,1), expand = c(0,0))
plt
head(df)
mean(df$correct[df$given_instruction == 1 & df$second_half == 0,])
mean(df$correct[df$given_instruction == 1 & df$second_half == 0])
mean(df$correct[df$given_instruction == 1 & df$second_half == 1])
mean(df$correct[df$given_instruction == 0 & df$second_half == 0])
mean(df$correct[df$given_instruction == 0 & df$second_half == 1])
head(fx)
desc_dats <- df %>%
group_by(given_instruction, second_half) %>%
summarise(accuracy = mean(correct))
desc_dats
desc_sim <- fx %>%
group_by(condition) %>%
summarise(accuracy = mean(samples))
desc_sim
desc_dats$condition <- c("Baseline",
"Instructed",
"Practice",
"Transfer")
desc_dats
desc_dats$condition <- c("Baseline",
"Practice",
"Instructed",
"Transfer")
desc_dats
desc_dats$type <- c("Real_data")
rm(decs_dats)
rm(desc_dats)
desc_dat <- df %>%
group_by(given_instruction, second_half) %>%
summarise(accuracy = mean(correct))
desc_dat$condition <- c("Baseline",
"Practice",
"Instructed",
"Transfer")
desc_dat$type <- c("Real_data")
head(desc_sim)
desc_dat <- select(desc_dat,
condition,
accuracy,
type)
View(desc_dat)
desc_dat <- df %>%
group_by(given_instruction, second_half) %>%
summarise(accuracy = mean(correct))
desc_dat$condition <- c("Baseline",
"Practice",
"Instructed",
"Transfer")
desc_dat$type <- c("Real_data")
desc_dat <- select(desc_dat,
condition,
accuracy,
type)
desc_dat <- df %>%
group_by(given_instruction, second_half) %>%
summarise(accuracy = mean(correct))
desc_dat$condition <- c("Baseline",
"Practice",
"Instructed",
"Transfer")
desc_dat$type <- c("Real_data")
head(desc_dat)
desc_dat <- select(desc_dat,
accuracy:type)
desc_dat <- df %>%
group_by(given_instruction, second_half) %>%
summarise(accuracy = mean(correct)) %>%
ungroup()
desc_dat$condition <- c("Baseline",
"Practice",
"Instructed",
"Transfer")
desc_dat$type <- c("Real_data")
desc_dat <- select(desc_dat,
accuracy:type)
View(desc_dat)
desc_sim$type <- c("Sim_data")
avg_acc <- rbind(desc_dat, desc_sim)
avg_acc
desc_dat <- df %>%
group_by(given_instruction, second_half) %>%
summarise(accuracy = mean(correct)) %>%
ungroup()
desc_dat$condition <- c("Baseline",
"Practice",
"Instructed",
"Transfer")
desc_dat$type <- c("Real_data")
desc_dat <- select(desc_dat,
condition,
type,
accuracy)
desc_sim <- fx %>%
group_by(condition) %>%
summarise(accuracy = mean(samples))
desc_sim$type <- c("Sim_data")
# compare groups
avg_acc <- rbind(desc_dat, desc_sim)
avg_acc
fit6 <- stan(
file = "mafc_regression.stan",
data = cha_dat,
chains = 1,
warmup = 1000,
iter = 2000,
refresh = 100,
control = list(adapt_delta = 0.99)
)
post_fit6_1 <- post_fit6
plot(x,y)
lines(x, logistic(pmax(0,b*x+c)))
plot(x,y)
lines(x, logistic(pmax(0,b*x+c)))
post_fit6 <- rstan::extract(fit6)
b <- mean(post_fit6$b)
c <- mean(post_fit6$c)
# good(ish) plot, bad model
plot(x,y)
lines(x, logistic(pmax(0,b*x+c)))
m3_1 <- stan(
file = "exp3_m3_2.stan",
data = stan_df,
chains = 1,
warmup = 1000,
iter = 2000,
refresh = 100
)
m3_1 <- stan(
file = "exp3_m3_2.stan",
data = stan_df,
chains = 1,
warmup = 1000,
iter = 2000,
refresh = 100
)
m3_1 <- stan(
file = "exp3_m3_2.stan",
data = stan_df,
chains = 1,
warmup = 1000,
iter = 2000,
refresh = 100
)
m3_1 <- stan(
file = "exp3_m3_2.stan",
data = stan_df,
chains = 1,
warmup = 1000,
iter = 2000,
refresh = 100
)
m3_1 <- stan(
file = "exp3_m3_2.stan",
data = stan_df,
chains = 1,
warmup = 1000,
iter = 2000,
refresh = 100
)
m3_1 <- stan(
file = "exp3_m3_2.stan",
data = stan_df,
chains = 1,
warmup = 1000,
iter = 2000,
refresh = 100
)
m3_1
pairs(m3_1)
pairs(m3_1)
dev.off()
paris(m3_1)
pairs(m3_1)
dev.off()
m3_1 <- stan(
file = "exp3_m3_2.stan",
data = stan_df,
chains = 1,
warmup = 1000,
iter = 2000,
refresh = 100
)
temp <- rstan::extract(m3_1)
temp
View(temp)
summary(m3_1)
m3_1
m3_2 <- m3_1
load("scratch/models/m3_1")
m3_1
m3_2
logit(0.94 + 0.33)
logit((0.94 + 0.33))
0.94 = 0.33
0.94 + 0.33
logistic(1.27)
logistic(0.94)
logistic(0.94 + 0.34)
logistic(0.94 + 0.34 - 0.28)
View(m3_2)
m3_2$mu
m3_1 <- stan(
file = "exp3_m3_2.stan",
data = stan_df,
chains = 1,
warmup = 1000,
iter = 2000,
refresh = 100
)
m3_1
m3_1
logistic(0.89)
logistic(0.89 + 0.66)
logistic(0.89 + 0.13)
logistic(0.89 + 0.66 - 0.55)
avg_acc
post_samples <- as.tibble(rstan::extract(m3_1))
# for a better plot
get_fx_for_sep <- function(post) {
# get fixed effects of model
# d is the scaled separtations we want to predict for
fx <- tibble(
condition = rep(c(
"Baseline",
"Instructed",
"Practice",
"Transfer"), each = length(post$c)),
samples = c(
plogis(post$c),
plogis(post$c + post$b_i),
plogis(post$c + post$b_h),
plogis(post$c + post$b_i + post$b_h + post$b_hi)))
return(fx)
}
fx_min_sep  <- get_fx_for_sep(min(df$sep_scaled), post_samples)
fx_mean_sep <- get_fx_for_sep(mean(df$sep_scaled), post_samples)
fx_max_sep  <- get_fx_for_sep(max(df$sep_scaled), post_samples)
fx <- get_fx_for_sep(post_samples)
plt <- ggplot(fx, aes(x = samples, fill = condition))
plt <- plt + geom_density(alpha = 0.5)
plt <- plt + theme_bw()  + scale_fill_viridis_d()
# plt <- plt + facet_wrap(~delta)
plt <- plt + scale_x_continuous(
name = "probablity of correctly responding to target", limits = c(0.5,1), expand = c(0,0))
plt
mafc.logit
stan_df <- list(
N = nrow(df),
inst = df$given_instruction,
acc = df$correct,
delta = df$sep_scaled,
half = df$second_half
)
m3 <- stan(
file = "exp3_m3.stan",
data = stan_df,
chains = 1,
warmup = 1000,
iter = 2000,
refresh = 100
)
m3
m3
logistic(2.21)
logistic(2.21 - 3.29)
logistic(2.21 - 3.29 + 0.73)
logistic(2.21+ 0.73)
logistic(2.21+ 0.73 - 3.29)
m3 <- stan(
file = "exp3_m3_1.stan",
data = stan_df,
chains = 1,
warmup = 1000,
iter = 2000,
refresh = 100
)
m3_1
m3
logistic(2.22)
logistic(2.22 -3.31)
m3_1 <- m3
save(m3_1, file = "scratch/models/m3_1")
load("scratch/models/m3")
m3
m3_1
logistic(2.22 + (0.5*-3.31))
logistic(1.31 - 0.8)
m3_5 <- m3
m3 <- stan(
file = "exp3_m3.stan",
data = stan_df,
chains = 1,
warmup = 1000,
iter = 2000,
refresh = 100
)
m3
m3_5
logistic(1.31-0.8)
logistic(2.22-3.31)
logistic(2.22)
logistic(1.31)
m3 <- stan(
file = "exp3_m3.stan",
data = stan_df,
chains = 1,
warmup = 1000,
iter = 2000,
refresh = 100
)
m3
save(m3, file = "scratch/models/m3")
rm(list = ls())
