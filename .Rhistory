#        - Optimal Accuracy
#        - Centre strat Accuracy; do we need this?
# And probably the same for fixation proportions
#### libraries needed ####
library(tidyverse)
library(reshape2) # probably needed to make wide data
#### load in data ####
# part 2 data
load("scratch/Ellen_switch_nar_data")
# Accuracy across separations
load("scratch/acc_sep")
# add in expected accuracy column given separation
switch_df <- merge(acc_sep, switch_df, by = c("participant", "separation"))
# reorder
switch_df <- select(switch_df,
participant,
block,
trial,
separation,
fixated_box,
correct,
num_fish,
score,
switch_point,
centre,
accuracy)
# probably want to round switch_point
switch_df$switch_point <- as.numeric(switch_df$switch_point)
switch_df$switch_point <- round(switch_df$switch_point)
# check switch points against accuracy
temp <- group_by(switch_df, participant, separation)
temp <- summarise(temp, mean_acc = mean(accuracy))
switch_points <- group_by(switch_df, participant)
switch_points <- summarise(switch_points, switch_point = unique(switch_point))
temp <- merge(temp, switch_points)
View(temp)
write.table(temp, "check_switch_points", row.names = FALSE, sep = "\t")
rm(list = ls())
setwd("E:/Github/TargetAbsentStoppingRules/analysis")
library(brms)
library(rstan)
library(tidyverse)
load("scratch/models/brm_m5_5")
load("scratch/models/brm_m5_5")
m5_5_effects <- marginal_effects(m5_5_rt_theta_bt_prt)
plot(m5_effects, plot = TRUE)
plot(m5_5_effects, plot = TRUE)
plot(m5_5_effects, plot = TRUE)
plot(m5_5_effects, plot = FALSE)[[4]] +
ggplot2::ggtitle("Model with interaction of Block type and Difficulty (Theta)") +
ggplot2::theme(plot.title = element_text(hjust = 0.5)) +
ggplot2::labs(y = "RT", x = "Theta")
load("scratch/models/brm_m4")
# marginal effects
m4_effects <- marginal_effects(m4_rt_theta_bt)
# make plots
plot(m4_effects, plot = FALSE)[[3]] +
ggplot2::ggtitle("Model with interaction of Block type and Difficulty (Theta)") +
ggplot2::theme(plot.title = element_text(hjust = 0.5)) +
ggplot2::labs(y = "RT", x = "Theta")
rm(list = ls())
library(tidyverse)
load("scratch/Elle_switch_nar_data")
setwd("E:/Github/Instructed_Eye_movements")
load("scratch/Elle_switch_nar_data")
head(swtich_df)
head(switch_df)
library(tidyverse)
load("scratch/Elle_switch_nar_data")
head(switch_df)
head(switch_df)
head(switch_df, addrownums = FALSE)
head(switch_df, addrownums = FALSE)
switch_df$switch_point <- as.numeric(switch_df$switch_point)
switch_df$switch_point <- round(switch_df$switch_point)
head(switch_df, addrownums = FALSE)
rm(list = ls())
#### Creating new datasets ####
# Level 4 Thesis by Elle
# 2017/18
# Written by Warren James
# Script for processing data to be analysed by Elle
# This script will produce datasets about:
# Expected accuracy had they performed optimally
# Expected accuracy based on fixation locations (to account for chance)
# Actual Accuracy accross blocks:
#    - Doesn't Alasdair's script do this one?
# Proportion of time looking at side vs centre across 9 tested distances
#    - Also by block number (first half vs second half)
#### libraries needed ####
library(tidyverse)
library(reshape2)
library(psyphy)
#### Extra information ####
# I think there were 36 pixels per degree... Will have to check though
pixVD = 0.036
options(digits = 4)
#### Read in part 1 measures for accuracy across distances ####
# create dataframe
df <- tibble(
block = numeric(),
separation = numeric(),
accuracy = numeric()
)
# colnames
import_names <- c(
"block",
"separation",
"accuracy"
)
# set up directory for loop
results_files <- dir("data/results/Part_1/")
# read in data
for (f in results_files){
d <- read.csv(
paste("data/results/Part_1/", f, sep=""), header = F)
# change column names
names(d) <- import_names
# get parts of the string for part no. and session number
temp <- strsplit(f, '[_]')[[1]]
# now input this information
d$participant <- temp[2]
# bind to df
df <- bind_rows(df, d)
}
# tidy
rm(d, f, import_names, results_files, temp)
# re-order
df <- select(df,
participant,
block,
separation,
accuracy)
# remove NA trials
df <- df[complete.cases(df),]
#### Calculate curve for accuracy across distances ####
sep <- c(1:450)
# data frame for accuracy accross separations
acc_sep <- tibble(
participant = character(),
separation = numeric(),
accuracy = numeric()
)
# loop through participants for accuracy over all separations
# very slow loop... must be a quicker way to do this?
# the for(i in 1:640) causes it to slow... Can do this another way?
#for (p in unique(df$participant))
#{
#  # general linear model
#  ss = df[which(df$participant==p),]
#  m = glm(data=ss, accuracy~separation, family=binomial(mafc.probit(2)))
#  for(i in 1:640){
#    y = predict(m, data.frame(separation = i), type = "response")
#
#    # add into new data frame
#    acc_sep <- rbind(acc_sep, data.frame(participant = p,
#                                         separation  = i,
#                                         accuracy = y))
#  }
#}
# participant 1 might need to be excluded
# save this
# save(acc_sep, file = "scratch/acc_sep")
# load in the above
load("scratch/acc_sep")
# tidy
# rm(m, ss, i, p, sep, y)
# tidy if loop not run
rm(sep)
#### Part 1 plots ####
# remove NA's
df_nar <- df[complete.cases(df),]
# summary data for mean accuracy
temp <- group_by(df_nar, participant, separation)
agdat <- summarise(temp, meanAcc = mean(accuracy))
# tidy
rm(temp)
# make plot
plt = ggplot(df_nar, aes(x=separation, y=accuracy))
plt = plt + stat_smooth(colour="black", method=glm, method.args = list(family=binomial(mafc.probit(2))), se=F, fullrange=TRUE)
plt = plt + geom_point(data=agdat, aes(x=separation, y=meanAcc))
plt = plt + facet_wrap(~participant) + theme_minimal()
plt = plt + scale_y_continuous(name="proportion correct", breaks=c(0.25, 0.5, 0.75, 1.0))
plt = plt + scale_x_continuous(name="separation (pixels for now)", limits=c(0,450), breaks=c(0,150,300,450))
# ggsave("scratch/plots/Part_1_Plots.pdf", height = 10, width = 10)
# or as png?
# ggsave("scratch/plots/Part_1_Plots.png")
# tidy
rm(plt, agdat)
#### part 2 data ####
# lod in part 2 data with switch points
load("scratch/Elle_switch_nar_data")
# add in expected accuracy column given separation
switch_df <- merge(acc_sep, switch_df, by = c("participant", "separation"))
# reorder
switch_df <- select(switch_df,
participant,
part,
block,
separation,
fixated_box,
correct,
switch_point,
condition,
centre,
accuracy)
# probably want to round switch_point
switch_df$switch_point <- as.numeric(switch_df$switch_point)
switch_df$switch_point <- round(switch_df$switch_point)
# check switch points against accuracy
temp <- group_by(switch_df, participant, separation)
temp <- summarise(temp, mean_acc = mean(accuracy))
switch_points <- group_by(switch_df, participant)
switch_points <- summarise(switch_points, switch_point = unique(switch_point))
temp <- merge(temp, switch_points)
View(temp)
rm(list = ls())
library(tidyverse)
knitr::opts_chunk$set(fig.width=6, fig.height=3)
load("scratch/Elle_switch_nar_data")
# round switch point
switch_df$switch_point <- as.numeric(switch_df$switch_point)
switch_df$switch_point <- round(switch_df$switch_point)
# show first few lines of data set
head(switch_df)
no_inst_1 <- switch_df[switch_df$condition == "No_instructions" &
switch_df$block < 5,]
# no instructions/second half
no_inst_2 <- switch_df[switch_df$condition == "No_instructions" &
switch_df$block > 4,]
# instructions/tutorial
inst_tut <- switch_df[switch_df$condition == "Instructions" &
switch_df$part == 3,]
# instructions/task
inst_tas <- switch_df[switch_df$condition == "Instructions" &
switch_df$part == 2,]
fh_tut <- rbind(inst_tut, no_inst_1)
# set data for boxplts
temp <- group_by(fh_tut,
participant,
condition)
ftut_box_dat <- summarise(temp,
correct = mean(correct))
View(ftut_box_dat)
temp <- group_by(fh_tut, condition)
ftut_overall <- summarise(temp,
correct = mean(correct),
sdev = sd(correct))
View(ftut_overall)
ftut_bo_dat <- summarise(temp,
correct = mean(correct),
sdev = sd(correct))
View(ftut_overall)
View(ftut_bo_dat)
ftut_overall$correct[ftut_overall$condition == "Instructions"]
View(ftut_overall)
round(ftut_overall$correct[ftut_overall$condition == "No_Instructions"], digits = 3)
View(ftut_overall)
View(fh_tut)
View(fh_tut)
library(tidyverse)
knitr::opts_chunk$set(fig.width=6, fig.height=3)
load("scratch/Elle_switch_nar_data")
# round switch point
switch_df$switch_point <- as.numeric(switch_df$switch_point)
switch_df$switch_point <- round(switch_df$switch_point)
# show first few lines of data set
head(switch_df)
# no instructions/first half
no_inst_1 <- switch_df[switch_df$condition == "No_instructions" &
switch_df$block < 5,]
# no instructions/second half
no_inst_2 <- switch_df[switch_df$condition == "No_instructions" &
switch_df$block > 4,]
# instructions/tutorial
inst_tut <- switch_df[switch_df$condition == "Instructions" &
switch_df$part == 3,]
# instructions/task
inst_tas <- switch_df[switch_df$condition == "Instructions" &
switch_df$part == 2,]
# First half
fh_tut <- rbind(inst_tut, no_inst_1)
# set data for boxplts
temp <- group_by(fh_tut,
participant,
condition)
ftut_box_dat <- summarise(temp,
correct = mean(correct))
# tidy
rm(temp)
# get numbers for in text
temp <- group_by(fh_tut, condition)
ftut_overall <- summarise(temp,
correct = mean(correct))
# make plots
ftut_box_plt <- ggplot(ftut_box_dat,
aes(condition,
correct))
ftut_box_plt <- ftut_box_plt + geom_boxplot()
ftut_box_plt <- ftut_box_plt + ggtitle("First Half")
# display plots
ftut_box_plt
library(tidyverse)
knitr::opts_chunk$set(fig.width=6, fig.height=3)
load("scratch/Elle_switch_nar_data")
# round switch point
switch_df$switch_point <- as.numeric(switch_df$switch_point)
switch_df$switch_point <- round(switch_df$switch_point)
# show first few lines of data set
head(switch_df)
# no instructions/first half
no_inst_1 <- switch_df[switch_df$condition == "No_instructions" &
switch_df$block < 5,]
# no instructions/second half
no_inst_2 <- switch_df[switch_df$condition == "No_instructions" &
switch_df$block > 4,]
# instructions/tutorial
inst_tut <- switch_df[switch_df$condition == "Instructions" &
switch_df$part == 3,]
# instructions/task
inst_tas <- switch_df[switch_df$condition == "Instructions" &
switch_df$part == 2,]
# First half
fh_tut <- rbind(inst_tut, no_inst_1)
# set data for boxplts
temp <- group_by(fh_tut,
participant,
condition)
ftut_box_dat <- summarise(temp,
correct = mean(correct))
# tidy
rm(temp)
# get numbers for in text
temp <- group_by(fh_tut, condition)
ftut_overall <- summarise(temp,
correct = mean(correct))
# make plots
ftut_box_plt <- ggplot(ftut_box_dat,
aes(condition,
correct))
ftut_box_plt <- ftut_box_plt + geom_boxplot()
ftut_box_plt <- ftut_box_plt + ggtitle("First Half")
# display plots
ftut_box_plt
# Second half
sh_tas <- rbind(inst_tas, no_inst_2)
# set data for boxplts
temp <- group_by(sh_tas,
participant,
condition)
stas_box_dat <- summarise(temp,
correct = mean(correct))
# tidy
rm(temp)
# get numbers for in text
temp <- group_by(sh_tas, condition)
stas_overall <- summarise(temp,
correct = mean(correct))
# make plots
stas_box_plt <- ggplot(stas_box_dat,
aes(condition,
correct))
stas_box_plt <- stas_box_plt + geom_boxplot()
stas_box_plt <- stas_box_plt + ggtitle("Second Half")
# show plot
stas_box_plt
temp <- group_by(fh_tut, participant,separation,condition)
centre_prop <- summarise(temp, prop_fixated = mean(centre))
centre_prop$box <- "centre"
# side proportions
side_prop <- summarise(temp, prop_fixated = 1 - mean(centre))
side_prop$box <- "side"
# tidy
rm(temp)
# merge data
plt_dat_fh <- rbind(centre_prop, side_prop)
rm(centre_prop, side_prop)
View(plt_dat_fh)
temp <- group_by(fh_tut, participant, condition)
switch_points <- summarise(temp, switch_point = unique(switch_point))
temp <- group_by(fh_tut, participant)
switch_points <- summarise(temp, switch_point = unique(switch_point))
rm(list = ls())
library(tidyverse)
knitr::opts_chunk$set(fig.width=6, fig.height=3)
load("scratch/Elle_switch_nar_data")
# round switch point
switch_df$switch_point <- as.numeric(switch_df$switch_point)
switch_df$switch_point <- round(switch_df$switch_point)
# show first few lines of data set
head(switch_df)
# no instructions/first half
no_inst_1 <- switch_df[switch_df$condition == "No_instructions" &
switch_df$block < 5,]
# no instructions/second half
no_inst_2 <- switch_df[switch_df$condition == "No_instructions" &
switch_df$block > 4,]
# instructions/tutorial
inst_tut <- switch_df[switch_df$condition == "Instructions" &
switch_df$part == 3,]
# instructions/task
inst_tas <- switch_df[switch_df$condition == "Instructions" &
switch_df$part == 2,]
# First half
fh_tut <- rbind(inst_tut, no_inst_1)
# set data for boxplts
temp <- group_by(fh_tut,
participant,
condition)
ftut_box_dat <- summarise(temp,
correct = mean(correct))
# tidy
rm(temp)
# get numbers for in text
temp <- group_by(fh_tut, condition)
ftut_overall <- summarise(temp,
correct = mean(correct))
# make plots
ftut_box_plt <- ggplot(ftut_box_dat,
aes(condition,
correct))
ftut_box_plt <- ftut_box_plt + geom_boxplot()
ftut_box_plt <- ftut_box_plt + ggtitle("First Half")
# display plots
ftut_box_plt
# Second half
sh_tas <- rbind(inst_tas, no_inst_2)
# set data for boxplts
temp <- group_by(sh_tas,
participant,
condition)
stas_box_dat <- summarise(temp,
correct = mean(correct))
# tidy
rm(temp)
# get numbers for in text
temp <- group_by(sh_tas, condition)
stas_overall <- summarise(temp,
correct = mean(correct))
# make plots
stas_box_plt <- ggplot(stas_box_dat,
aes(condition,
correct))
stas_box_plt <- stas_box_plt + geom_boxplot()
stas_box_plt <- stas_box_plt + ggtitle("Second Half")
# show plot
stas_box_plt
# centre proportions
temp <- group_by(fh_tut, participant,separation,condition)
centre_prop <- summarise(temp, prop_fixated = mean(centre))
centre_prop$box <- "centre"
# side proportions
side_prop <- summarise(temp, prop_fixated = 1 - mean(centre))
side_prop$box <- "side"
# tidy
rm(temp)
# merge data
plt_dat_fh <- rbind(centre_prop, side_prop)
# tidy
rm(centre_prop, side_prop)
# add back in switch_points
temp <- group_by(fh_tut, participant)
switch_points <- summarise(temp, switch_point = unique(switch_point))
# make plot
# tidy
rm(temp)
# now to make the plots
prop_plt_fh <- ggplot(data = plt_dat_fh,
aes(x = separation,
y = prop_fixated))
prop_plt_fh <- prop_plt_fh + geom_area(aes(colour = box,
fill = box),
position = "stack")
prop_plt_fh <- prop_plt_fh + geom_vline(data = switch_points,
aes(xintercept = as.numeric(switch_point)),
linetype = "dashed")
prop_plt_fh <- prop_plt_fh + facet_wrap(~condition + participant)
prop_plt_fh
prop_plt_fh <- ggplot(data = plt_dat_fh,
aes(x = separation,
y = prop_fixated))
prop_plt_fh
prop_plt_fh <- prop_plt_fh + geom_area(aes(colour = box,
fill = box),
position = "stack")
fill = box),
prop_plt_fh
prop_plt_fh <- prop_plt_fh + geom_vline(data = switch_points,
aes(xintercept = as.numeric(switch_point)),
linetype = "dashed")
prop_plt_fh
prop_plt_fh <- prop_plt_fh + facet_wrap(~condition + participant)
prop_plt_fh
temp <- group_by(fh_tut, participant, condition)
switch_points <- summarise(temp, switch_point = unique(switch_point))
# make plot
# tidy
rm(temp)
# now to make the plots
prop_plt_fh <- ggplot(data = plt_dat_fh,
aes(x = separation,
y = prop_fixated))
prop_plt_fh <- prop_plt_fh + geom_area(aes(colour = box,
fill = box),
position = "stack")
prop_plt_fh <- prop_plt_fh + geom_vline(data = switch_points,
aes(xintercept = as.numeric(switch_point)),
linetype = "dashed")
prop_plt_fh <- prop_plt_fh + facet_wrap(~condition + participant)
prop_plt_fh
prop_plt_fh
rm(list = ls())
