temp <- post$a + post$b * i
Expected_height <- mean(temp)
Int89 <- HPDI(temp, prob = 0.89)
lower <- Int89[1]
upper <- Int89[2]
d = rbind(d, data.frame(weights_to_check[i], Expected_height, lower, upper))
}
for(i in weights_to_check) {
temp <- post$a + post$b * i
Expected_height <- mean(temp)
Int89 <- HPDI(temp, prob = 0.89)
lower <- Int89[1]
upper <- Int89[2]
d = rbind(d, data.frame(i, Expected_height, lower, upper))
}
d = NULL
for(i in weights_to_check) {
temp <- post$a + post$b * i
Expected_height <- mean(temp)
Int89 <- HPDI(temp, prob = 0.89)
lower <- Int89[1]
upper <- Int89[2]
d = rbind(d, data.frame(i, Expected_height, lower, upper))
}
head(d)
d = NULL
for(i in weights_to_check) {
temp <- post$a + post$b * i
Expected_height <- mean(temp)
Int89 <- HPDI(temp, prob = 0.89)
lower <- Int89[1]
upper <- Int89[2]
Weights <- i
d = rbind(d, data.frame(Weights, Expected_height, lower, upper))
}
head(d)
d = NULL
for(i in weights_to_check) {
temp <- post$a + post$b * i
Expected_height <- mean(temp)
Int89 <- HPDI(temp, prob = 0.89)
lower <- Int89[1,]
upper <- Int89[2,]
Weights <- i
d = rbind(d, data.frame(Weights, Expected_height, lower, upper))
}
d = NULL
for(i in weights_to_check) {
temp <- post$a + post$b * i
Expected_height <- mean(temp)
Int89 <- HPDI(temp, prob = 0.89)
lower <- Int89[,1]
upper <- Int89[,2]
Weights <- i
d = rbind(d, data.frame(Weights, Expected_height, lower, upper))
}
d = NULL
for(i in weights_to_check) {
temp <- post$a + post$b * i
Expected_height <- mean(temp)
Int89 <- HPDI(temp, prob = 0.89)
lower <- Int89[1]
upper <- Int89[2]
Weights <- i
d = rbind(d, data.frame(Weights, Expected_height, lower, upper))
}
temp <- post$a + post$b * 50
HDPI(temp)
HPDI(temp)
HPDI(temp)[1]
HPDI(temp)[2]
head(d)
d
data(islandsDistMatrix)
Dmat <- islandsDistMatrix
library(rethinking)
data(islandsDistMatrix)
Dmat <- islandsDistMatrix
data("Kline2")
d <- Kline2
# tidy
rm(Kline2)
# prep indexes
d$society <- 1:10
m13.7 <- map2stan(
alist(
total_tools ~ dpois(lambda),
log(lambda) <- a + g[society] + bp*logpop,
g[society] ~ GPL2( Dmat , etasq , rhosq , 0.01 ),
a ~ dnorm(0,10),
bp ~ dnorm(0,1),
etasq ~ dcauchy(0,1),
rhosq ~ dcauchy(0,1)
),
data=list(
total_tools=d$total_tools,
logpop=d$logpop,
society=d$society,
Dmat=islandsDistMatrix),
warmup=2000 , iter=1e4 , chains=4)
precis(m13.7,depth=2)
post <- extract.samples(m13.7)
curve(median(post$etasq)*exp(-median(post$rhosq)*x^2), from = 0, to = 10,
xlab = "dist (thousand km", ylab = "covariance", ylim = c(0,1),
yaxp = c(0,1,4), lwd=2)
curve(median(post$etasq)*exp(-median(post$rhosq)*x^2), from = 0, to = 10,
xlab = "dist (thousand km", ylab = "covariance", ylim = c(0,1),
yaxp = c(0,1,4), lwd=2)
# plot 100 function samples
for( i in 1:100)
curve(post$etasq[i]*exp(-post$rhosq[i]*x^2), add = T,
col = col.alpha("black", 0.2))
dev.off()
K <- matrix(0, nrow = 10, ncol = 10)
for(i in 1:10)
for(j in 1:10)
K[i,j] <- median(post$etasq) *
exp(-median(post$rhosq) *
islandsDistMatrix[i,j]^2)
diag(K) <- median(post$etasq) + 0.01
Rho <- round(cov2cor(K), 2)
# add names for convenience
colnames(Rho) <- c("Ml","Ti","SC","Ya","Fi","Tr","Ch","Mn","To","Ha")
rownames(Rho) <- colnames(Rho)
Rhow
Rho
psize <- d$logpop/max(d$logpop)
psize <- exp(psize*1.5)-2
# plot raw data and labels
plot(d$lon2, d$lat, xlab = "longitude", ylab = "latitude",
col = randi2, cex = psize, pch = 16, xlim = c(-50,30))
labels <- as.character(d$culture)
text(d$lon2, d$lat, labels = labels, cex = 0.7, pos = c(2,4,3,3,4,1,3,2,4,2))
# overlay lines
for(i in 1:10)
for(j in 1:10)
if(i < j)
lines(c(d$lon2[i],d$lon2[j]), c(d$lat[i], d$lat[j]),
lwd=2, col = col.alpha("black", Rho[i,j]^2))
psize <- d$logpop/max(d$logpop)
psize <- exp(psize*1.5)-2
# plot raw data and labels
plot(d$lon2, d$lat, xlab = "longitude", ylab = "latitude",
col = randi2, cex = psize, pch = 16, xlim = c(-50,30))
labels <- as.character(d$culture)
text(d$lon2, d$lat, labels = labels, cex = 0.7, pos = c(2,4,3,3,4,1,3,2,4,2))
# overlay lines
for(i in 1:10)
for(j in 1:10)
if(i < j)
lines(c(d$lon2[i],d$lon2[j]), c(d$lat[i], d$lat[j]),
lwd=2, col = col.alpha("black", Rho[i,j]^2))
plot(d$lon2, d$lat, xlab = "longitude", ylab = "latitude",
col = rangi2, cex = psize, pch = 16, xlim = c(-50,30))
labels <- as.character(d$culture)
text(d$lon2, d$lat, labels = labels, cex = 0.7, pos = c(2,4,3,3,4,1,3,2,4,2))
# overlay lines
for(i in 1:10)
for(j in 1:10)
if(i < j)
lines(c(d$lon2[i],d$lon2[j]), c(d$lat[i], d$lat[j]),
lwd=2, col = col.alpha("black", Rho[i,j]^2))
logpop.seq <- seq( from=6 , to=14 , length.out=30 )
lambda <- sapply( logpop.seq ,
function(lp) exp( post$a + post$bp*lp ) )
lambda.median <- apply( lambda , 2 , median )
lambda.PI80 <- apply( lambda , 2 , PI , prob=0.8 )
# plot raw data and labels
plot( d$logpop ,
d$total_tools ,
col=rangi2 ,
cex=psize ,
pch=16 ,
xlab="log population" ,
ylab="total tools" )
text( d$logpop ,
d$total_tools ,
labels=labels ,
cex=0.7 ,
pos=c(4,3,4,2,2,1,4,4,4,2) )
# display posterior predictions
lines( logpop.seq ,
lambda.median ,
lty=2 )
lines( logpop.seq ,
lambda.PI80[1,] ,
lty=2 )
lines( logpop.seq ,
lambda.PI80[2,] ,
lty=2 )
# overlay correlations
for( i in 1:10 )
for ( j in 1:10 )
if ( i < j )
lines( c( d$logpop[i],d$logpop[j] ) ,
c( d$total_tools[i],d$total_tools[j] ) ,
lwd=2 , col=col.alpha("black",Rho[i,j]^2) )
setwd("F:/Uni/PhD/1st year/Groups/Level 4/Elle")
#### libraries needed ####
library(tidyverse)
#### load in the dataset ####
# create a tibble for dataset
df <- tibble(
block = numeric(),
separation = numeric(),
fixated_box = numeric(),
correct = numeric())
# create column names for the data we have
import_names <- c(
"block",
"separation",
"fixated_box",
"correct")
# set up directory for loop
results_files <- dir("data/results/Part_2-3/")
# read in each data file
for (f in results_files){
d <- read.csv(
paste("data/results/Part_2-3/", f, sep=""), header = F)
# change column names
names(d) <- import_names
# get parts of the string for part no. and session number
temp <- strsplit(f, '[_]')[[1]]
# now input this information
d$participant <- temp[2]
d$part <- substring(temp[4],5,5)
# bind to df
df <- bind_rows(df, d)
}
# tidy
rm(temp, f, d, import_names, results_files)
# re-order the dataset
df <- select(df,
participant,
part,
block,
separation,
fixated_box,
correct)
# save processed data file
save(df, file = "scratch/Elle_data")
# tidy
rm(df)
#### libraries needed ####
library(tidyverse)
library(R.matlab)
# load in the data set
load("scratch/Elle_data")
# create a tibble for switch points
switch_df <- tibble(
participant = numeric(),
switch_point = numeric()
)
results_files <- dir("data/switching_points/")
# add in a counter to assign the row
count <- 1
# read in the Matlab data
#temp <- readMat("data/switching_points/0_99.mat")
for (f in results_files){
d <- readMat(
paste("data/switching_points/", f, sep=""))
# get switch point
d <- d$switchdist[1]
# get parts of the string for part no.
temp <- strsplit(f, '[_.]')[[1]]
# now input this information
switch_df[count,] <- c(temp[2], d)
# increas the count
count <- count + 1
}
# tidy
rm(count, d, f, temp, results_files)
# combine the datasets
switch_df <- merge(df, switch_df, by="participant")
# tidy
rm(df)
#### add in condition part ####
# Turn "part" numeric for the loop
switch_df$part <- as.numeric(switch_df$part)
for(i in unique(switch_df$participant)){
if(mean(switch_df$part[switch_df$participant == i]) > 2)
{
switch_df$condition[switch_df$participant == i] <- "Instructions"
} else {
switch_df$condition[switch_df$participant == i] <- "No_instructions"
}
}
#tidy
rm(i)
#### Create column for whether they made the optimal choice or not ####
# Make side vs centre first
# Think this is right, check the script though
# 1 = left, 2 = middle, 3 = right
switch_df$centre <- 0
switch_df$centre[switch_df$fixated_box == 2] <- 1
#### save the file (everything) ####
save(switch_df, file = "scratch/Elle_switch_data")
#### Create version with Na's removed ####
switch_df <- switch_df[complete.cases(switch_df),]
# create save files
save(switch_df, file = "scratch/Elle_switch_nar_data")
View(switch_df)
setwd("F:/Uni/Github/Instructed_Eye_movements")
#### libraries needed ####
library(tidyverse)
#### load in the dataset ####
# create a tibble for dataset
df <- tibble(
block = numeric(),
separation = numeric(),
fixated_box = numeric(),
correct = numeric())
# create column names for the data we have
import_names <- c(
"block",
"separation",
"fixated_box",
"correct")
# set up directory for loop
results_files <- dir("data/results/Part_2-3/")
# read in each data file
for (f in results_files){
d <- read.csv(
paste("data/results/Part_2-3/", f, sep=""), header = F)
# change column names
names(d) <- import_names
# get parts of the string for part no. and session number
temp <- strsplit(f, '[_]')[[1]]
# now input this information
d$participant <- temp[2]
d$part <- substring(temp[4],5,5)
# bind to df
df <- bind_rows(df, d)
}
# tidy
rm(temp, f, d, import_names, results_files)
# re-order the dataset
df <- select(df,
participant,
part,
block,
separation,
fixated_box,
correct)
# save processed data file
save(df, file = "scratch/Elle_data")
# tidy
rm(df)
rm(switch_df)
#### libraries needed ####
library(tidyverse)
library(R.matlab)
# load in the data set
load("scratch/Elle_data")
# create a tibble for switch points
switch_df <- tibble(
participant = numeric(),
switch_point = numeric()
)
results_files <- dir("data/switching_points/")
# add in a counter to assign the row
count <- 1
# read in the Matlab data
#temp <- readMat("data/switching_points/0_99.mat")
for (f in results_files){
d <- readMat(
paste("data/switching_points/", f, sep=""))
# get switch point
d <- d$switchdist[1]
# get parts of the string for part no.
temp <- strsplit(f, '[_.]')[[1]]
# now input this information
switch_df[count,] <- c(temp[2], d)
# increas the count
count <- count + 1
}
# tidy
rm(count, d, f, temp, results_files)
# combine the datasets
switch_df <- merge(df, switch_df, by="participant")
# tidy
rm(df)
#### add in condition part ####
# Turn "part" numeric for the loop
switch_df$part <- as.numeric(switch_df$part)
for(i in unique(switch_df$participant)){
if(mean(switch_df$part[switch_df$participant == i]) > 2)
{
switch_df$condition[switch_df$participant == i] <- "Instructions"
} else {
switch_df$condition[switch_df$participant == i] <- "No_instructions"
}
}
#tidy
rm(i)
#### Create column for whether they made the optimal choice or not ####
# Make side vs centre first
# Think this is right, check the script though
# 1 = left, 2 = middle, 3 = right
switch_df$centre <- 0
switch_df$centre[switch_df$fixated_box == 2] <- 1
#### save the file (everything) ####
save(switch_df, file = "scratch/Elle_switch_data")
#### Create version with Na's removed ####
switch_df <- switch_df[complete.cases(switch_df),]
# create save files
save(switch_df, file = "scratch/Elle_switch_nar_data")
rm(switch_df)
#### Plotting Script ####
# Level 4 Thesis by Elle
# 2017/18
# Written by Warren James
# Script used to make plots of proportion of fixations
# made to the centre or side box(es)
#### libraries needed ####
library(tidyverse)
#### load in data ####
load("scratch/Elle_switch_nar_data")
#### separate datasets ####
# this part is so we have a separate dataset for:
# no instructions/first half
no_inst_1 <- switch_df[switch_df$condition == "No_instructions" &
switch_df$block < 5,]
# no instructions/second half
no_inst_2 <- switch_df[switch_df$condition == "No_instructions" &
switch_df$block > 4,]
# instructions/tutorial
inst_tut <- switch_df[switch_df$condition == "Instructions" &
switch_df$part == 3,]
# instructions/task
inst_tas <- switch_df[switch_df$condition == "Instructions" &
switch_df$part == 2,]
#### Assuming we only want to look at part 2 for each participant ####
df_part2 <- switch_df[switch_df$part == 2,]
#### make plots ####
# setup data.frame/tibble for plots
# centre proportions
temp <- group_by(df_part2, participant,separation,condition)
centre_prop <- summarise(temp, prop_fixated = mean(centre))
centre_prop$box <- "centre"
# side proportions
side_prop <- summarise(temp, prop_fixated = 1 - mean(centre))
side_prop$box <- "side"
# tidy
rm(temp)
# merge data
plt_dat <- rbind(centre_prop, side_prop)
# tidy
rm(centre_prop, side_prop)
# need to add switch point data back in
temp <- group_by(df_part2, participant, condition)
switch_points <- summarise(temp, switch_point = unique(switch_point))
# tidy
rm(temp)
# now to make the plots
prop_plt <- ggplot(data = plt_dat,
aes(x = separation,
y = prop_fixated))
prop_plt <- prop_plt + geom_area(aes(colour = box,
fill = box),
position = "stack")
prop_plt <- prop_plt + geom_vline(data = switch_points,
aes(xintercept = as.numeric(switch_point)),
linetype = "dashed")
prop_plt <- prop_plt + facet_wrap(~condition + participant)
prop_plt
# save plot
# ggsave("scratch/proportions_plot.pdf", width = 10, height = 10)
#### boxplots of accuracy ####
# make boxplot data
temp <- group_by(switch_df, participant, condition)
box_dat <- summarise(temp, correct = mean(correct))
# tidy
rm(temp)
# make plots
box_plt <- ggplot(box_dat,
aes(condition,
correct))
box_plt <- box_plt + geom_boxplot()
#### compare: first half and tutorial ####
fh_tut <- rbind(inst_tut, no_inst_1)
# set data for boxplts
temp <- group_by(fh_tut,
participant,
condition)
ftut_box_dat <- summarise(temp,
correct = mean(correct))
# tidy
rm(temp)
# make plots
ftut_box_plt <- ggplot(ftut_box_dat,
aes(condition,
correct))
ftut_box_plt <- ftut_box_plt + geom_boxplot()
#### compare: second half and task ####
sh_tas <- rbind(inst_tas, no_inst_2)
# set data for boxplts
temp <- group_by(sh_tas,
participant,
condition)
stas_box_dat <- summarise(temp,
correct = mean(correct))
# tidy
rm(temp)
# make plots
stas_box_plt <- ggplot(stas_box_dat,
aes(condition,
correct))
stas_box_plt <- stas_box_plt + geom_boxplot()
ftut_box_plt
stas_box_plt
rm(list = ls())
