x <- 1-(0.1*d)
x <- abs(runif(1, x-0.1, x))
}
a <- rbinom(trials, 1, x)
a <- sum(a)/max(trials)
dat_part1 <- rbind(dat_part1, data.frame(Participant = p,
Distances = d,
Accuracy = a))
}
}
# tidy
rm(a,d,p,x,Distances,Participants,trials)
# get glm of this data just to see what it looks like
m = glm(data=dat_part1, Accuracy~Distances:Participant,
family= binomial)
dat_part1$p <- predict(m, type = "response")
# plot this to check
plt <- ggplot(dat_part1, aes(Distances, Accuracy))
plt <- plt + geom_point()
plt <- plt + geom_smooth(method=glm,
method.args = list(family = "binomial"),
aes(y=p),
fullrange=T, se=F)
plt <- plt + facet_wrap(~Participant)
plt
rm(m, plt)
get_VisDegs <- function(separation,distance){
((2*atan2(separation,(2*distance)))*180)/pi
}
Screen_dist <- 53
ppcm <- 1920/54
a <- c(100, 140, 188, 246, 304, 362, 410, 450)
get_VisDegs(a/ppcm, Screen_dist)
a <- c(100, 140, 188, 246, 304, 362, 410, 450, 1920/2)
get_VisDegs(a/ppcm, Screen_dist)
temp <- c(90, 75, 25, 10)
(temp*0.9) + 0.1
(temp*0.9) + 10
setwd("F:/Uni/PhD/1st year/Table Transfer Task/Anca")
library(tidyverse)
#### Any constants ####
slab_size <- 0.46
#### LOAD ####
#### LOAD: part 1 ####
df_P1 <- read.table("data/part_1/allDataAcc.txt", header = T)
# make participant a factor
df_P1$Participant <- as.factor(df_P1$Participant)
# collapse across directions and session
df_P1 <- df_P1 %>%
group_by(Participant, Distance) %>%
summarise(Accuracy = sum(Accuracy))
# sort out accuracy measure
df_P1$trials <- 24
df_P1$Acc <- df_P1$Accuracy/df_P1$trials
# do we need the offset?
df_P1$off_set <- log((1-0.01)/0.01)
#### LOAD: Part 2 ####
load("scratch/df_P2")
# get distance from each hoop
df_P2$South_dist <- abs(df_P2$hoop_dist - df_P2$Position)
df_P2$North_dist <- abs(df_P2$hoop_dist + df_P2$Position)
#### Get Accuracy accross distances ####
# setup the glm
acc_sep <- tibble(Participant = character(),
Distance = numeric(),
pred_Acc = numeric())
# setup vector of slabs
separations <- c(0:50)
# run GLM for switch points
for(p in levels(df_P1$Participant)){
# subset
ss = df_P1[df_P1$Participant == p,]
# run glm
m = glm(data = ss, Acc~Distance,
family = binomial)
y = predict(m, data.frame(Distance = separations), type = "response")
# y = as.numeric(p)
# bind this to acc_sep
acc_sep <- rbind(acc_sep, data.frame(Participant = p,
Distance = seq(0:50),
pred_acc = y))
}
# tidy
rm(m, ss, p, separations, y)
#### Sort out estimates ####
# this doesn't work...
acc_sep$Distance <- acc_sep$Distance - 1
# now sort out distances part
north_acc <- acc_sep
colnames(north_acc) <- c("Participant",
"North_dist",
"pred_north")
south_acc <- acc_sep
colnames(south_acc) <- c("Participant",
"South_dist",
"pred_south")
# merge separately
df_P2 <- merge(df_P2, north_acc)
df_P2 <- merge(df_P2, south_acc)
# tidy
rm(north_acc, south_acc)
df_P2$Exp_acc <- (df_P2$pred_north + df_P2$pred_south)/2
# remove unused columns
df_P2 <- select(df_P2,
Participant,
Trial,
Position,
Accuracy,
Condition,
Session,
hoop_dist,
Norm_pos,
switch_point,
Exp_acc)
# now sort out Optimal standing pos
df_P2$opt_pos <- 0
df_P2$opt_pos[df_P2$hoop_dist > df_P2$switch_point] <- 1
df_P2$Opt_acc <- df_P2$Exp_acc
df_P2$Opt_acc[df_P2$opt_pos == 1] <- 0.5
# again, reduce data set
df_P2 <- select(df_P2,
Participant,
Trial,
Position,
Accuracy,
Condition,
Session,
hoop_dist,
Norm_pos,
switch_point,
Exp_acc,
Opt_acc)
#### PLOTS ####
#### PLOTS: Each session accuracy ####
# setup data frame
plt_dat <- df_P2 %>%
group_by(Participant, Condition, Session) %>%
summarise(Actual = mean(Accuracy),
Optimal = mean(Opt_acc),
Expected = mean(Exp_acc))
# need to sort levels
levels(plt_dat$Condition) <- c("Control", "Primed", "Primed")
levels(plt_dat$Session) <- c("First Session", "Second Session")
# make plot
plt <- ggplot(plt_dat, aes(Optimal, Actual,
colour = Condition))
plt <- plt + theme_bw()
plt <- plt + geom_point()
plt <- plt + geom_abline(intercept = 0, slope = 1)
plt <- plt + facet_wrap(~ Session)
plt
rm(a)
rm(Screen_dist, temp, get_VisDegs())
rm(Screen_dist, temp, get_VisDegs
)
rm(ppcm)
#### PLOTS: Plot of standing position ####
# setup data
plt_dat2 <- df_P2 %>%
group_by(Participant, Session, Condition, hoop_dist) %>%
summarise(Position = mean(Norm_pos))
# need to sort levels
levels(plt_dat2$Condition) <- c("Control", "Primed", "Primed")
levels(plt_dat2$Session) <- c("First Session", "Second Session")
# only second session
plt_dat2 <- plt_dat2[plt_dat2$Session == "Second Session",]
# plot
plt2 <- ggplot(plt_dat2, aes(hoop_dist*slab_size, Position,
colour = Condition))
plt2 <- plt2 + theme_bw()
plt2 <- plt2 + geom_point()
plt2 <- plt2 + geom_line(aes(group = Participant))
plt2$labels$x <- "Delta (metres)"
plt2$labels$y <- "Normalise standing position"
plt2
plt
rm(list = ls())
#### Anca study: Optimal Accuracy script ####
# Getting optimal accuracy vs. actual
# Also standing position
# making these one plot together
#### libraries ####
library(tidyverse)
library(gridExtra)
#### Any constants ####
slab_size <- 0.46
#### LOAD ####
#### LOAD: part 1 ####
df_P1 <- read.table("data/part_1/allDataAcc.txt", header = T)
# make participant a factor
df_P1$Participant <- as.factor(df_P1$Participant)
# collapse across directions and session
df_P1 <- df_P1 %>%
group_by(Participant, Distance) %>%
summarise(Accuracy = sum(Accuracy))
# sort out accuracy measure
df_P1$trials <- 24
df_P1$Acc <- df_P1$Accuracy/df_P1$trials
# do we need the offset?
df_P1$off_set <- log((1-0.01)/0.01)
#### LOAD: Part 2 ####
load("scratch/df_P2")
# get distance from each hoop
df_P2$South_dist <- abs(df_P2$hoop_dist - df_P2$Position)
df_P2$North_dist <- abs(df_P2$hoop_dist + df_P2$Position)
#### Get Accuracy accross distances ####
# setup the glm
acc_sep <- tibble(Participant = character(),
Distance = numeric(),
pred_Acc = numeric())
# setup vector of slabs
separations <- c(0:50)
# run GLM for switch points
for(p in levels(df_P1$Participant)){
# subset
ss = df_P1[df_P1$Participant == p,]
# run glm
m = glm(data = ss, Acc~Distance,
family = binomial)
y = predict(m, data.frame(Distance = separations), type = "response")
# y = as.numeric(p)
# bind this to acc_sep
acc_sep <- rbind(acc_sep, data.frame(Participant = p,
Distance = seq(0:50),
pred_acc = y))
}
# tidy
rm(m, ss, p, separations, y)
#### Sort out estimates ####
# this doesn't work...
acc_sep$Distance <- acc_sep$Distance - 1
# now sort out distances part
north_acc <- acc_sep
colnames(north_acc) <- c("Participant",
"North_dist",
"pred_north")
south_acc <- acc_sep
colnames(south_acc) <- c("Participant",
"South_dist",
"pred_south")
# merge separately
df_P2 <- merge(df_P2, north_acc)
df_P2 <- merge(df_P2, south_acc)
# tidy
rm(north_acc, south_acc)
df_P2$Exp_acc <- (df_P2$pred_north + df_P2$pred_south)/2
# remove unused columns
df_P2 <- select(df_P2,
Participant,
Trial,
Position,
Accuracy,
Condition,
Session,
hoop_dist,
Norm_pos,
switch_point,
Exp_acc)
# now sort out Optimal standing pos
df_P2$opt_pos <- 0
df_P2$opt_pos[df_P2$hoop_dist > df_P2$switch_point] <- 1
df_P2$Opt_acc <- df_P2$Exp_acc
df_P2$Opt_acc[df_P2$opt_pos == 1] <- 0.5
# again, reduce data set
df_P2 <- select(df_P2,
Participant,
Trial,
Position,
Accuracy,
Condition,
Session,
hoop_dist,
Norm_pos,
switch_point,
Exp_acc,
Opt_acc)
#### PLOTS ####
#### PLOTS: Each session accuracy ####
# setup data frame
plt_dat <- df_P2 %>%
group_by(Participant, Condition, Session) %>%
summarise(Actual = mean(Accuracy),
Optimal = mean(Opt_acc),
Expected = mean(Exp_acc))
# need to sort levels
levels(plt_dat$Condition) <- c("Control", "Primed", "Primed")
levels(plt_dat$Session) <- c("First Session", "Second Session")
# make plot
plt <- ggplot(plt_dat, aes(Optimal, Actual,
colour = Condition))
plt <- plt + theme_bw()
plt <- plt + geom_point()
plt <- plt + geom_abline(intercept = 0, slope = 1)
plt <- plt + facet_wrap(~ Session)
plt
#### PLOTS: Plot of standing position ####
# setup data
plt_dat2 <- df_P2 %>%
group_by(Participant, Session, Condition, hoop_dist) %>%
summarise(Position = mean(Norm_pos))
# need to sort levels
levels(plt_dat2$Condition) <- c("Control", "Primed", "Primed")
levels(plt_dat2$Session) <- c("First Session", "Second Session")
# only second session
plt_dat2 <- plt_dat2[plt_dat2$Session == "Second Session",]
# plot
plt2 <- ggplot(plt_dat2, aes(hoop_dist*slab_size, Position,
colour = Condition))
plt2 <- plt2 + theme_bw()
plt2 <- plt2 + geom_point()
plt2 <- plt2 + geom_line(aes(group = Participant))
plt2$labels$x <- "Delta (metres)"
plt2$labels$y <- "Normalise standing position"
plt2
#### PLOTS: Put together ####
grid.arrange(plt, pl2, ncol = 1)
grid.arrange(plt, plt2, ncol = 1)
plt_dat2
View(plt_dat2)
View(plt_dat)
dir()
dir("scratch")
rm(list = ls())
dev.off()
library(tidyverse)
p_throw <- function(x) {
# define throwing model
b <- -1
c <- 6
# use inverse logit transform to get probabilities
y <- plogis(b * x + c)
return(y)
}
exp_acc <- function(delta) {
s_pos <- seq(0, 1, 0.01) # normalised standing position, where 1 = delta
sp = s_pos * delta
# work out expected accuracy given standing position (sp) and delta
# for hoop one
p <- colMeans(rbind(p_throw(abs(delta - sp)), p_throw(abs(delta + sp))))
# express expected accuracy as a prop. or maximum possible
y <- p / max(p)
return(y)
}
delta <- seq(1,15,0.1)
expected_accs <- as.data.frame(sapply(delta, exp_acc))
names(expected_accs) <- delta
expected_accs$standing_position <- seq(0, 1, 0.01)
# reshape for ggplotting
expected_accs <- gather(expected_accs, 1:length(delta), key = "delta", value = "p", -standing_position)
expected_accs <- as.tibble(expected_accs)
expected_accs$delta = as.numeric(expected_accs$delta)
expected_accs <- arrange(expected_accs, delta)
plt <- ggplot(expected_accs, aes(x = standing_position, y = p, color = delta))
plt <- plt + geom_path()
plt
thresh <- c(0.5, 0.80, .90)
dat <- tibble()
for (t in thresh)
{
expected_accs$good_enough <- expected_accs$p > t
d <- aggregate(data = expected_accs, good_enough ~ delta, FUN = mean)
d$threshold <- t
dat <- bind_rows(dat, d)
}
dat$threshold <- as.factor(dat$threshold)
plt <- ggplot(dat, aes(x = delta, y = good_enough, colour = threshold, group = threshold))
plt <- plt + geom_point() + geom_path()
plt <- plt + scale_y_continuous("prop. of space that is good enough", limits = c(0, 1))
plt <- plt + scale_x_continuous("delta: hoop separation")
plt
rm(list = ls())
setwd("F:/Uni/Github/Instructed_Eye_movements")
#### Analysis ####
# Level 4 Thesis by Elle
# 2017/18
# Written by Warren James
# Script to carry out the planned analyses
#### Libraries ####
library(tidyverse)
library(gridExtra)
#### any functions ####
get_VisDegs <- function(separation,distance){
((2*atan2(separation,(2*distance)))*180)/pi
}
#### Constants ####
Screen_dist <- 53
ppcm <- 1920/54
#### Extra information ####
# I think there were 36 pixels per degree... Will have to check though
pixVD = 0.036
options(digits = 4)
#### load in data ####
load("scratch/switch_df")
# reduce columns down to what we need
df <- select(switch_df,
participant,
condition,
separation,
part,
half,
block,
separation,
fixated_box,
correct,
opt_acc,
exp_acc)
# tidy
rm(switch_df)
#### ANALYSIS ####
#### ANALYSIS: Difference session 2 ####
# Get a difference score for second half sessions for both groups. Then compare these together.
# Smaller values means closer to the optimal accuracy level.
# first set up data frame
dat_analysis <- df %>%
group_by(participant, condition, half) %>%
summarise(Act_Accuracy = mean(correct),
Opt_Accuracy = mean(opt_acc),
Exp_Accuracy = mean(exp_acc))
# make some variabls factors
dat_analysis$condition <- as.factor(dat_analysis$condition)
dat_analysis$half <- as.factor(dat_analysis$half)
# Get difference score
dat_analysis$difference <- dat_analysis$Opt_Accuracy - dat_analysis$Act_Accuracy
# now we only want the second half
dat_analysis_1 <- dat_analysis[dat_analysis$half == "second",]
# now do t-test
t_test_diff_1 <- t.test(dat_analysis_1$difference ~
dat_analysis_1$condition)
# not sig, but we know that from the bayesian regression model
#### ANALYSIS: Difference for session 1 ####
# same as above, but for first session
dat_analysis_2 <- dat_analysis[dat_analysis$half == "first",]
# now test
t_test_diff_2 <- t.test(dat_analysis_2$difference ~
dat_analysis_2$condition)
# This is significant though...
#### ANALYSIS: Practice effects ####
# just use "No_instructions" group and compare accross halves
dat_analysis_3 <- dat_analysis[dat_analysis$condition == "No_instructions",]
# now test
t_test_prac <- t.test(dat_analysis_3$difference ~
dat_analysis_3$half)
# This isn't sig... so no real practice effects present
t_test_diff_1
dat_analysis_1$difference_2 <- dat_analysis_1$Opt_Accuracy - dat_analysis_1$Exp_Accuracy
t_test_diff_1_1 <- t.test(dat_analysis_1$difference ~
dat_analysis_1$condition)
t_test_diff_1_1
View(dat_analysis_1)
t_test_diff_1_1 <- t.test(dat_analysis_1$difference_2 ~
dat_analysis_1$condition)
t_test_diff_1_1
t_test_diff_2
t_test_diff_2 <- t.test(dat_analysis_2$difference ~
dat_analysis_2$condition,
var.equal = T)
t_test_diff_2
t_test_diff_1 <- t.test(dat_analysis_1$difference ~
dat_analysis_1$condition,
var.equal = T)
t_test_diff_1
# now test
t_test_prac <- t.test(dat_analysis_3$difference ~
dat_analysis_3$half,
var.equal = T)
t_test_prac
t_test_diff_1 <- t.test(dat_analysis_1$difference ~
dat_analysis_1$condition,
alternative = c("greater"),
var.equal = T)
t_test_diff_1
t_test_diff_1_1
t_test_diff_1_1 <- t.test(dat_analysis_1$difference_2 ~
dat_analysis_1$condition,
alternative = c("greater"),
var.equal = T)
t_test_diff_1_1
t_test_diff_2
t_test_diff_2 <- t.test(dat_analysis_2$difference ~
dat_analysis_2$condition,
alternative = c("greater"),
var.equal = T)
t_test_diff_2
t_test_diff_2 <- t.test(dat_analysis_2$difference ~
dat_analysis_2$condition,
alternative = c("less"),
var.equal = T)
t_test_diff_2
t_test_prac
t_test_prac <- t.test(dat_analysis_3$difference ~
dat_analysis_3$half,
alternative = c("greater"),
var.equal = T)
t_test_prac
dev.off()
# now do t-test
t_test_diff_1 <- t.test(dat_analysis_1$difference ~
dat_analysis_1$condition,
# alternative = c("greater"),
var.equal = T)
t_test_diff_1
t_test_diff_1 <- t.test(dat_analysis_1$difference ~
dat_analysis_1$condition,
alternative = c("greater"),
var.equal = T)
t_test_diff_1
t_test_diff_1 <- t.test(dat_analysis_1$difference ~
dat_analysis_1$condition,
alternative = c("less"),
var.equal = T)
t_test_diff_1
t_test_diff_1$p.value
