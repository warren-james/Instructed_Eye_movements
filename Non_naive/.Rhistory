plt = ggplot(df_nar, aes(x=get_VisDegs(separation/ppcm,Screen_dist), y=accuracy))
plt = plt + stat_smooth(method=glm,
method.args = list(family=binomial(mafc.probit(2))),
se=F,
fullrange=TRUE)
plt = plt + geom_point(data=agdat,
aes(x=get_VisDegs(separation/ppcm,Screen_dist),
y=meanAcc))
plt = plt + facet_wrap(~participant) + theme_bw()
plt = plt + scale_y_continuous(name="Accuracy",
breaks=c(0.25, 0.5, 0.75, 1.0))
plt = plt + scale_x_continuous(name="Delta (Visial Degrees)",
breaks = c(3,6,9,12))#, limits=c(0,450), breaks=c(0,150,300,450))
# ggsave("scratch/plots/Part_1_Josephine.pdf", height = 6, width = 6)
# or as png?
# ggsave("scratch/plots/Part_1_Plots.png", height = 6, width = 8)
# tidy
rm(plt, agdat)
#### CHECKED UP TO HERE ####
# The below still needs to be checked to help streamline everything
#### part 2 data ####
# load in part 2 data with switch points
load("scratch/switch_nar_data")
# add in expected accuracy column given separation
switch_df <- merge(acc_sep, switch_df, by = c("participant", "separation"))
# reorder
switch_df <- select(switch_df,
participant,
part,
block,
separation,
fixated_box,
correct,
switch_point,
centre,
accuracy)
# probably want to round switch_point
switch_df$switch_point <- as.numeric(switch_df$switch_point)
switch_df$switch_point <- round(switch_df$switch_point)
# check switch points against accuracy
temp <- group_by(switch_df, participant, separation)
temp <- summarise(temp, mean_acc = mean(accuracy))
switch_points <- group_by(switch_df, participant)
switch_points <- summarise(switch_points, switch_point = unique(switch_point))
temp <- merge(temp, switch_points)
# tidy
rm(temp)
# NB: as.factor() then as.numeric() will produce a number for each level
#     Use this to transform data so it's standardised accross participants
#     order of levels is important though so be careful
#     might need to reorder the levels before you do this
#     Though there seem to be nine levels for each participant, not 7?
#### Standardise separations ####
for(i in unique(switch_df$participant)){
switch_df$standard_sep[switch_df$participant == i] <- as.numeric(as.factor(switch_df$separation[switch_df$participant == i]))
}
# subtract 5 to centre the switch point
switch_df$standard_sep <- switch_df$standard_sep - 5
#tidy
rm(i)
#### column for accuracy given fixation location ####
# gives accuracy given where they looked based on separation
switch_df$act_acc <- switch_df$accuracy
switch_df$act_acc[switch_df$centre == 0] <- 0.75
#### make column for optimal accuracy ####
# first make opt fixation location
switch_df$opt_fix <- 0
# # this way gives some people opt accuracy below 0.75, may need to redefine their accuracy?
# switch_df$opt_fix[switch_df$separation > switch_df$switch_point] <- 1
# This way should work
switch_df$opt_fix[switch_df$accuracy > 0.75] <- 1
# now give accuracy if they had followed this strategy
switch_df$opt_acc <- switch_df$accuracy
switch_df$opt_acc[switch_df$opt_fix == 0] <- 0.75
# Now get Expected Accuracy
switch_df$exp_acc <- switch_df$accuracy
switch_df$exp_acc[switch_df$centre == 0] <- 0.75
#### Accuracy: make new datasets ####
# first, set first half vs second half
switch_df$half[switch_df$block < 5] <- "first"
switch_df$half[switch_df$block > 4] <- "second"
#### sort for Joespine ####
switch_df$Vis_Degs <- get_VisDegs(switch_df$separation/ppcm, Screen_dist)
#Actual
Act_Acc_vdegs <- switch_df %>%
group_by(participant, Vis_Degs) %>%
summarise(mean_acc = mean(correct))
Act_Acc_vdegs$acc_type <- "Actual"
#Optimal
Opt_Acc_vdegs <- switch_df %>%
group_by(participant, Vis_Degs) %>%
summarise(mean_acc = mean(opt_acc))
Opt_Acc_vdegs$acc_type <- "Optimal"
# combine these
Accuracy_vdegs <- rbind(Act_Acc_vdegs, Opt_Acc_vdegs)
# save this
write.table(Accuracy_vdegs, file = "scratch/Accuracy_Vdegs_us.txt", row.names = F, sep = "\t")
#### Accuracy: Actual ####
# sort out actual accuracy
temp <- group_by(switch_df, participant, half, standard_sep)
Act_accuracy <- summarise(temp, mean_acc = mean(correct))
# define type of accuracy
Act_accuracy$acc_type <- "Actual"
# change column names
colnames(Act_accuracy) <- c("participant",
"half",
"standard_sep",
"Accuracy",
"acc_type")
#### Accuracy: Optimal ####
# Add in optimal accuracy
Opt_accuracy <- summarise(temp, mean_opt = mean(opt_acc))
# define type of accuracy
Opt_accuracy$acc_type <- "Optimal"
# change column names
colnames(Opt_accuracy) <- c("participant",
"half",
"standard_sep",
"Accuracy",
"acc_type")
#### Accuracy: Expected Actual ####
# sort expected actual accuracy
Exp_accuracy <- summarise(temp, mean_exp = mean(exp_acc))
# define type of accuracy
Exp_accuracy$acc_type <- "Expected"
# change column names
colnames(Exp_accuracy) <- c("participant",
"half",
"standard_sep",
"Accuracy",
"acc_type")
# tidy
rm(temp)
#### Accuracy: Combine these? ####
accuracy_data <- rbind(Exp_accuracy, Opt_accuracy, Act_accuracy)
# reorder
accuracy_data <- select(accuracy_data,
participant,
half,
standard_sep,
acc_type,
Accuracy)
View(accuracy_data)
9*5*3
save(accuracy_data, file = "scratch/accuracy_data")
rm(list = ls())
setwd("F:/Uni/PhD/1st year/Testing Us")
load("Detection/scratch/accuracy_data")
load("Throwing/scratch/predicted_accuracy")
dir()
dir("Detection")
dir("Detection/scratch")
rm(list = ls())
setwd("F:/Uni/PhD/1st year/Testing Us/Detection")
#### For Josephine ####
#### libraries needed ####
library(tidyverse)
library(reshape2)
library(psyphy)
#### Any Functions ####
# function to get VisDegs
get_VisDegs <- function(x,y){
(2*atan2(x,(2*y)))*(180/pi)
}
#### Constants ####
Screen_dist <- 53
ppcm <- 1920/54
#### Extra information ####
options(digits = 4)
#### Read in part 1 measures for accuracy across distances ####
# create dataframe
df <- tibble(
block = numeric(),
separation = numeric(),
accuracy = numeric()
)
# colnames
import_names <- c(
"block",
"separation",
"accuracy"
)
# set up directory for loop
results_files <- dir("data/results/Part_1/")
# read in data
for (f in results_files){
d <- read.csv(
paste("data/results/Part_1/", f, sep=""), header = F)
# change column names
names(d) <- import_names
# get parts of the string for part no. and session number
temp <- strsplit(f, '[_]')[[1]]
# now input this information
d$participant <- temp[2]
# bind to df
df <- bind_rows(df, d)
}
# tidy
rm(d, f, import_names, results_files, temp)
# re-order
df <- select(df,
participant,
block,
separation,
accuracy)
# remove NA trials
df <- df[complete.cases(df),]
df_part1 <- df
# load in part 2
load("scratch/df_part2")
df_part2 <- df
# tidy
rm(df)
#### Calculate curve for accuracy across distances ####
# not needed....
# sep <- c(min(df_part2$separation):(2*max(df_part2$separation)))
# data frame for accuracy accross separations
acc_sep <- tibble(
participant = character(),
separation = numeric(),
accuracy = numeric()
)
# loop through participants for accuracy over all separations
for (p in unique(df_part1$participant))
{
# general linear model
ss = df_part1[which(df_part1$participant==p),]
m = glm(data=ss, accuracy~separation, family=binomial(mafc.probit(2)))
for(i in 1:640){
y = predict(m, data.frame(separation = i), type = "response")
# add into new data frame
acc_sep <- rbind(acc_sep, data.frame(participant = p,
separation  = i,
accuracy = y))
}
}
# save this
save(acc_sep, file = "scratch/acc_sep")
# load in the above
# load("scratch/acc_sep")
# tidy
# rm(m, ss, i, p, sep, y)
# tidy if loop not run
rm(sep)
#### Part 1 plots ####
# remove NA's
df_nar <- df_part1[complete.cases(df_part1),]
# summary data for mean accuracy
temp <- group_by(df_nar, participant, separation)
agdat <- summarise(temp, meanAcc = mean(accuracy))
# tidy
rm(temp)
# make plot
plt = ggplot(df_nar, aes(x=get_VisDegs(separation/ppcm,Screen_dist), y=accuracy))
plt = plt + stat_smooth(method=glm,
method.args = list(family=binomial(mafc.probit(2))),
se=F,
fullrange=TRUE)
plt = plt + geom_point(data=agdat,
aes(x=get_VisDegs(separation/ppcm,Screen_dist),
y=meanAcc))
plt = plt + facet_wrap(~participant) + theme_bw()
plt = plt + scale_y_continuous(name="Accuracy",
breaks=c(0.25, 0.5, 0.75, 1.0))
plt = plt + scale_x_continuous(name="Delta (Visial Degrees)",
breaks = c(3,6,9,12))#, limits=c(0,450), breaks=c(0,150,300,450))
# ggsave("scratch/plots/Part_1_Josephine.pdf", height = 6, width = 6)
# or as png?
# ggsave("scratch/plots/Part_1_Plots.png", height = 6, width = 8)
# tidy
rm(plt, agdat)
#### CHECKED UP TO HERE ####
# The below still needs to be checked to help streamline everything
#### part 2 data ####
# load in part 2 data with switch points
load("scratch/switch_nar_data")
# add in expected accuracy column given separation
switch_df <- merge(acc_sep, switch_df, by = c("participant", "separation"))
# reorder
switch_df <- select(switch_df,
participant,
part,
block,
separation,
fixated_box,
correct,
switch_point,
centre,
accuracy)
# probably want to round switch_point
switch_df$switch_point <- as.numeric(switch_df$switch_point)
switch_df$switch_point <- round(switch_df$switch_point)
# check switch points against accuracy
temp <- group_by(switch_df, participant, separation)
temp <- summarise(temp, mean_acc = mean(accuracy))
switch_points <- group_by(switch_df, participant)
switch_points <- summarise(switch_points, switch_point = unique(switch_point))
temp <- merge(temp, switch_points)
# tidy
rm(temp)
# NB: as.factor() then as.numeric() will produce a number for each level
#     Use this to transform data so it's standardised accross participants
#     order of levels is important though so be careful
#     might need to reorder the levels before you do this
#     Though there seem to be nine levels for each participant, not 7?
#### Standardise separations ####
for(i in unique(switch_df$participant)){
switch_df$standard_sep[switch_df$participant == i] <- as.numeric(as.factor(switch_df$separation[switch_df$participant == i]))
}
# subtract 5 to centre the switch point
switch_df$standard_sep <- switch_df$standard_sep - 5
#tidy
rm(i)
#### column for accuracy given fixation location ####
# gives accuracy given where they looked based on separation
switch_df$act_acc <- switch_df$accuracy
switch_df$act_acc[switch_df$centre == 0] <- 0.75
#### make column for optimal accuracy ####
# first make opt fixation location
switch_df$opt_fix <- 0
# # this way gives some people opt accuracy below 0.75, may need to redefine their accuracy?
# switch_df$opt_fix[switch_df$separation > switch_df$switch_point] <- 1
# This way should work
switch_df$opt_fix[switch_df$accuracy > 0.75] <- 1
# now give accuracy if they had followed this strategy
switch_df$opt_acc <- switch_df$accuracy
switch_df$opt_acc[switch_df$opt_fix == 0] <- 0.75
# Now get Expected Accuracy
switch_df$exp_acc <- switch_df$accuracy
switch_df$exp_acc[switch_df$centre == 0] <- 0.75
#### Accuracy: make new datasets ####
# first, set first half vs second half
switch_df$half[switch_df$block < 5] <- "first"
switch_df$half[switch_df$block > 4] <- "second"
#### sort for Joespine ####
switch_df$Vis_Degs <- get_VisDegs(switch_df$separation/ppcm, Screen_dist)
#Actual
Act_Acc_vdegs <- switch_df %>%
group_by(participant, Vis_Degs) %>%
summarise(mean_acc = mean(correct))
Act_Acc_vdegs$acc_type <- "Actual"
#Optimal
Opt_Acc_vdegs <- switch_df %>%
group_by(participant, Vis_Degs) %>%
summarise(mean_acc = mean(opt_acc))
Opt_Acc_vdegs$acc_type <- "Optimal"
# combine these
Accuracy_vdegs <- rbind(Act_Acc_vdegs, Opt_Acc_vdegs)
# save this
write.table(Accuracy_vdegs, file = "scratch/Accuracy_Vdegs_us.txt", row.names = F, sep = "\t")
#### Accuracy: Actual ####
# sort out actual accuracy
temp <- group_by(switch_df, participant, half, standard_sep)
Act_accuracy <- summarise(temp, mean_acc = mean(correct))
# define type of accuracy
Act_accuracy$acc_type <- "Actual"
# change column names
colnames(Act_accuracy) <- c("participant",
"half",
"standard_sep",
"Accuracy",
"acc_type")
#### Accuracy: Optimal ####
# Add in optimal accuracy
Opt_accuracy <- summarise(temp, mean_opt = mean(opt_acc))
# define type of accuracy
Opt_accuracy$acc_type <- "Optimal"
# change column names
colnames(Opt_accuracy) <- c("participant",
"half",
"standard_sep",
"Accuracy",
"acc_type")
#### Accuracy: Expected Actual ####
# sort expected actual accuracy
Exp_accuracy <- summarise(temp, mean_exp = mean(exp_acc))
# define type of accuracy
Exp_accuracy$acc_type <- "Expected"
# change column names
colnames(Exp_accuracy) <- c("participant",
"half",
"standard_sep",
"Accuracy",
"acc_type")
# tidy
rm(temp)
#### Accuracy: Combine these? ####
accuracy_data <- rbind(Exp_accuracy, Opt_accuracy, Act_accuracy)
# reorder
accuracy_data <- select(accuracy_data,
participant,
half,
standard_sep,
acc_type,
Accuracy)
# save this
save(accuracy_data, file = "scratch/accuracy_data")
rm(list = ls())
setwd("F:/Uni/PhD/1st year/Testing Us")
load("Throwing/scratch/predicted_accuracy")
pred_dat_Throw <- df
# tidy
rm(df)
# now detection
load("Detection/scratch/accuracy_data")
pred_dat_Det <- accuracy_data
rm(accuracy_data)
head(pred_dat_Det)
head(pred_dat_Throw)
View(pred_dat_Throw)
View(pred_dat_Det)
temp <- pred_dat_Det %>%
group_by(participant, acc_type) %>%
summarise(Accuracy = mean(Accuracy))
head(temp)
head(plt_dat_Throw)
head(pred_dat_Throw)
colnames(plt_dat_det) <- c("Participant",
"Acc_type",
"Accuracy")
plt_dat_det <- pred_dat_Det %>%
group_by(participant, acc_type) %>%
summarise(Accuracy = mean(Accuracy))
# sort colnames
colnames(plt_dat_det) <- c("Participant",
"Acc_type",
"Accuracy")
head(plt_dat_det)
plt_dat_det$Task <- "Detection"
plt_dat_det
plt_dat_Throw <- pred_dat_Throw %>%
group_by(Participant, Acc_type) %>%
summarise(Accuracy = mean(Accuracy))
plt_dat_Throw$Task <- "Throwing"
plt_dat <- rbind(plt_dat_det, plt_dat_Throw)
head(plt_dat_det)
head(plt_dat_Throw)
str(plt_dat_det)
str(plt_dat_Throw)
plt_dat_det$Acc_type <- as.factor(plt_dat_det$Acc_type)
plt_dat <- rbind(plt_dat_det, plt_dat_Throw)
plt_dat <- merge(plt_dat_det, plt_dat_Throw)
plt_dat
plt_dat <- bind_rows(plt_dat_det, plt_dat_Throw)
rm(plt_dat)
rm(temp)
temp <- as.data.frame(plt_dat_det)
temp2 <- as.data.frame(plt_dat_Throw)
temp3 <- rbind(temp, temp2)
temp3
temp <- as.data.frame(plt_dat_det)
temp1 <- as.data.frame(plt_dat_Throw)
plt_dat <- rbind(temp, temp1)
plt_dat <- as.tibble(plt_dat)
head(plt_dat)
rm(plt_dat_det, plt_dat_Throw, temp, temp1)
rm(temp2, temp3)
plt_dat <- plt_dat[plt_dat$Acc_type == "Optimal" |
plt_dat$Acc_type == "Expected",]
head(plt_dat)
plt <- ggplot(plt_dat, aes(Acc_type, Accuracy))
plt <- plt + geom_point()
plt <- plt + facet_wrap(~Task)
plt
plt <- plt + geom_line()
plt
plt <- ggplot(plt_dat, aes(Acc_type, Accuracy))
plt <- plt + geom_point()
plt <- plt + stat_summary(fun.y=sum, geom="line")
plt <- plt + facet_wrap(~Task)
plt
plt <- ggplot(plt_dat, aes(Acc_type, Accuracy))
plt <- plt + geom_point()
plt <- plt + facet_wrap(~Task)
plt
plt <- ggplot(plt_dat, aes(Acc_type, Accuracy,
colour = Participant))
plt <- plt + geom_point()
plt <- plt + facet_wrap(~Task)
lt
plt
plt <- plt + geom_line()
plt
plt <- ggplot(plt_dat, aes(Acc_type, Accuracy))
plt <- plt + geom_point()
plt <- plt + geom_line()
plt <- plt + facet_wrap(~Task)
plt
plt <- plt + geom_line(aes(group = Participant))
plt
plt <- ggplot(plt_dat, aes(Acc_type, Accuracy))
plt <- plt + geom_point()
plt <- plt + geom_line(aes(group = Participant))
plt <- plt + facet_wrap(~Task)
plt
plt <- plt + theme_bw()
plt
plt <- plt + theme(strip.background = element_blank(),
strip.text.x = element_blank(),
text = element_text(size = 10))
plt
plt$labels$x <- "Accuracy Type"
plt <- ggplot(plt_dat, aes(Acc_type, Accuracy))
plt <- plt + theme_bw()
plt <- plt + geom_point()
plt <- plt + geom_line(aes(group = Participant))
plt <- plt + facet_wrap(~Task)
plt$labels$x <- "Accuracy Type"
plt
dir()
ggsave("Extra_plots/line_plot")
ggsave("Extra_plots/line_plot.png")
